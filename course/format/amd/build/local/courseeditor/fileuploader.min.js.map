{"version":3,"file":"fileuploader.min.js","sources":["../../../src/local/courseeditor/fileuploader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * The course file uploader.\n *\n * This module is used to upload files directly into the course.\n *\n * @module     core_courseformat/local/courseeditor/fileuploader\n * @copyright  2022 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * @typedef {Object} Handler\n * @property {String} extension the handled extension or * for any\n * @property {String} message the handler message\n * @property {String} module the module name\n */\n\nimport Config from 'core/config';\nimport ModalSaveCancel from 'core/modal_save_cancel';\nimport ModalEvents from 'core/modal_events';\nimport Templates from 'core/templates';\nimport {getFirst} from 'core/normalise';\nimport {prefetchStrings} from 'core/prefetch';\nimport {getString, getStrings} from 'core/str';\nimport {getCourseEditor} from 'core_courseformat/courseeditor';\nimport {processMonitor} from 'core/process_monitor';\nimport {debounce} from 'core/utils';\n\n// Uploading url.\nconst UPLOADURL = Config.wwwroot + '/course/dndupload.php';\nconst DEBOUNCETIMER = 500;\nconst USERCANIGNOREFILESIZELIMITS = -1;\n\n/** @var {ProcessQueue} uploadQueue the internal uploadQueue instance.  */\nlet uploadQueue = null;\n/** @var {Object} handlerManagers the courseId indexed loaded handler managers. */\nlet handlerManagers = {};\n/** @var {Map} courseUpdates the pending course sections updates. */\nlet courseUpdates = new Map();\n/** @var {Object} errors the error messages. */\nlet errors = null;\n\n// Load global strings.\nprefetchStrings('moodle', ['addresourceoractivity', 'upload']);\nprefetchStrings('core_error', ['dndmaxbytes', 'dndread', 'dndupload', 'dndunkownfile']);\n\n/**\n * Class to upload a file into the course.\n * @private\n */\nclass FileUploader {\n    /**\n     * Class constructor.\n     *\n     * @param {number} courseId the course id\n     * @param {number} sectionId the section id\n     * @param {number} sectionNum the section number\n     * @param {File} fileInfo the file information object\n     * @param {Handler} handler the file selected file handler\n     */\n    constructor(courseId, sectionId, sectionNum, fileInfo, handler) {\n        this.courseId = courseId;\n        this.sectionId = sectionId;\n        this.sectionNum = sectionNum;\n        this.fileInfo = fileInfo;\n        this.handler = handler;\n    }\n\n    /**\n     * Execute the file upload and update the state in the given process.\n     *\n     * @param {LoadingProcess} process the process to store the upload result\n     */\n    execute(process) {\n        const fileInfo = this.fileInfo;\n        const xhr = this._createXhrRequest(process);\n        const formData = this._createUploadFormData();\n\n        // Try reading the file to check it is not a folder, before sending it to the server.\n        const reader = new FileReader();\n        reader.onload = function() {\n            // File was read OK - send it to the server.\n            xhr.open(\"POST\", UPLOADURL, true);\n            xhr.send(formData);\n        };\n        reader.onerror = function() {\n            // Unable to read the file (it is probably a folder) - display an error message.\n            process.setError(errors.dndread);\n        };\n        if (fileInfo.size > 0) {\n            // If this is a non-empty file, try reading the first few bytes.\n            // This will trigger reader.onerror() for folders and reader.onload() for ordinary, readable files.\n            reader.readAsText(fileInfo.slice(0, 5));\n        } else {\n            // If you call slice() on a 0-byte folder, before calling readAsText, then Firefox triggers reader.onload(),\n            // instead of reader.onerror().\n            // So, for 0-byte files, just call readAsText on the whole file (and it will trigger load/error functions as expected).\n            reader.readAsText(fileInfo);\n        }\n    }\n\n    /**\n     * Returns the bind version of execute function.\n     *\n     * This method is used to queue the process into a ProcessQueue instance.\n     *\n     * @returns {Function} the bind function to execute the process\n     */\n    getExecutionFunction() {\n        return this.execute.bind(this);\n    }\n\n    /**\n     * Generate a upload XHR file request.\n     *\n     * @param {LoadingProcess} process the current process\n     * @return {XMLHttpRequest} the XHR request\n     */\n    _createXhrRequest(process) {\n        const xhr = new XMLHttpRequest();\n        // Update the progress bar as the file is uploaded.\n        xhr.upload.addEventListener(\n            'progress',\n            (event) => {\n                if (event.lengthComputable) {\n                    const percent = Math.round((event.loaded * 100) / event.total);\n                    process.setPercentage(percent);\n                }\n            },\n            false\n        );\n        // Wait for the AJAX call to complete.\n        xhr.onreadystatechange = () => {\n            if (xhr.readyState == 1) {\n                // Add a 1% just to indicate that it is uploading.\n                process.setPercentage(1);\n            }\n            // State 4 is DONE. Otherwise the connection is still ongoing.\n            if (xhr.readyState != 4) {\n                return;\n            }\n            if (xhr.status == 200) {\n                var result = JSON.parse(xhr.responseText);\n                if (result && result.error == 0) {\n                    // All OK.\n                    this._finishProcess(process);\n                } else {\n                    process.setError(result.error);\n                }\n            } else {\n                process.setError(errors.dndupload);\n            }\n        };\n        return xhr;\n    }\n\n    /**\n     * Upload a file into the course.\n     *\n     * @return {FormData|null} the new form data object\n     */\n    _createUploadFormData() {\n        const formData = new FormData();\n        try {\n            formData.append('repo_upload_file', this.fileInfo);\n        } catch (error) {\n            throw Error(error.dndread);\n        }\n        formData.append('sesskey', Config.sesskey);\n        formData.append('course', this.courseId);\n        formData.append('section', this.sectionNum);\n        formData.append('module', this.handler.module);\n        formData.append('type', 'Files');\n        return formData;\n    }\n\n    /**\n     * Finishes the current process.\n     * @param {LoadingProcess} process the process\n     */\n    _finishProcess(process) {\n        addRefreshSection(this.courseId, this.sectionId);\n        process.setPercentage(100);\n        process.finish();\n    }\n}\n\n/**\n * The file handler manager class.\n *\n * @private\n */\nclass HandlerManager {\n\n    /** @var {Object} lastHandlers the last handlers selected per each file extension. */\n    lastHandlers = {};\n\n    /** @var {Handler[]|null} allHandlers all the available handlers. */\n    allHandlers = null;\n\n    /**\n     * Class constructor.\n     *\n     * @param {Number} courseId\n     */\n    constructor(courseId) {\n        this.courseId = courseId;\n        this.lastUploadId = 0;\n        this.courseEditor = getCourseEditor(courseId);\n        if (!this.courseEditor) {\n            throw Error('Unkown course editor');\n        }\n        this.maxbytes = this.courseEditor.get('course')?.maxbytes ?? 0;\n    }\n\n    /**\n     * Load the course file handlers.\n     */\n    async loadHandlers() {\n        this.allHandlers = await this.courseEditor.getFileHandlersPromise();\n    }\n\n    /**\n     * Extract the file extension from a fileInfo.\n     *\n     * @param {File} fileInfo\n     * @returns {String} the file extension or an empty string.\n     */\n    getFileExtension(fileInfo) {\n        let extension = '';\n        const dotpos = fileInfo.name.lastIndexOf('.');\n        if (dotpos != -1) {\n            extension = fileInfo.name.substring(dotpos + 1, fileInfo.name.length).toLowerCase();\n        }\n        return extension;\n    }\n\n    /**\n     * Check if the file is valid.\n     *\n     * @param {File} fileInfo the file info\n     */\n    validateFile(fileInfo) {\n        if (this.maxbytes !== USERCANIGNOREFILESIZELIMITS && fileInfo.size > this.maxbytes) {\n            throw Error(errors.dndmaxbytes);\n        }\n    }\n\n    /**\n     * Get the file handlers of an specific file.\n     *\n     * @param {File} fileInfo the file indo\n     * @return {Array} Array of handlers\n     */\n    filterHandlers(fileInfo) {\n        const extension = this.getFileExtension(fileInfo);\n        return this.allHandlers.filter(handler => handler.extension == '*' || handler.extension == extension);\n    }\n\n    /**\n     * Get the Handler to upload a specific file.\n     *\n     * It will ask the used if more than one handler is available.\n     *\n     * @param {File} fileInfo the file info\n     * @returns {Promise<Handler|null>} the selected handler or null if the user cancel\n     */\n    async getFileHandler(fileInfo) {\n        const fileHandlers = this.filterHandlers(fileInfo);\n        if (fileHandlers.length == 0) {\n            throw Error(errors.dndunkownfile);\n        }\n        let fileHandler = null;\n        if (fileHandlers.length == 1) {\n            fileHandler = fileHandlers[0];\n        } else {\n            fileHandler = await this.askHandlerToUser(fileHandlers, fileInfo);\n        }\n        return fileHandler;\n    }\n\n    /**\n     * Ask the user to select a specific handler.\n     *\n     * @param {Handler[]} fileHandlers\n     * @param {File} fileInfo the file info\n     * @return {Promise<Handler>} the selected handler\n     */\n    async askHandlerToUser(fileHandlers, fileInfo) {\n        const extension = this.getFileExtension(fileInfo);\n        // Build the modal parameters from the event data.\n        const modalParams = {\n            title: getString('addresourceoractivity', 'moodle'),\n            body: Templates.render(\n                'core_courseformat/fileuploader',\n                this.getModalData(\n                    fileHandlers,\n                    fileInfo,\n                    this.lastHandlers[extension] ?? null\n                )\n            ),\n            saveButtonText: getString('upload', 'moodle'),\n        };\n        // Create the modal.\n        const modal = await this.modalBodyRenderedPromise(modalParams);\n        const selectedHandler = await this.modalUserAnswerPromise(modal, fileHandlers);\n        // Cancel action.\n        if (selectedHandler === null) {\n            return null;\n        }\n        // Save last selected handler.\n        this.lastHandlers[extension] = selectedHandler.module;\n        return selectedHandler;\n    }\n\n    /**\n     * Generated the modal template data.\n     *\n     * @param {Handler[]} fileHandlers\n     * @param {File} fileInfo the file info\n     * @param {String|null} defaultModule the default module if any\n     * @return {Object} the modal template data.\n     */\n    getModalData(fileHandlers, fileInfo, defaultModule) {\n        const data = {\n            filename: fileInfo.name,\n            uploadid: ++this.lastUploadId,\n            handlers: [],\n        };\n        let hasDefault = false;\n        fileHandlers.forEach((handler, index) => {\n            const isDefault = (defaultModule == handler.module);\n            data.handlers.push({\n                ...handler,\n                selected: isDefault,\n                labelid: `fileuploader_${data.uploadid}`,\n                value: index,\n            });\n            hasDefault = hasDefault || isDefault;\n        });\n        if (!hasDefault && data.handlers.length > 0) {\n            const lastHandler = data.handlers.pop();\n            lastHandler.selected = true;\n            data.handlers.push(lastHandler);\n        }\n        return data;\n    }\n\n    /**\n     * Get the user handler choice.\n     *\n     * Wait for the user answer in the modal and resolve with the selected index.\n     *\n     * @param {Modal} modal the modal instance\n     * @param {Handler[]} fileHandlers the availabvle file handlers\n     * @return {Promise} with the option selected by the user.\n     */\n    modalUserAnswerPromise(modal, fileHandlers) {\n        const modalBody = getFirst(modal.getBody());\n        return new Promise((resolve, reject) => {\n            modal.getRoot().on(\n                ModalEvents.save,\n                event => {\n                    // Get the selected option.\n                    const index = modalBody.querySelector('input:checked').value;\n                    event.preventDefault();\n                    modal.destroy();\n                    if (!fileHandlers[index]) {\n                        reject('Invalid handler selected');\n                    }\n                    resolve(fileHandlers[index]);\n\n                }\n            );\n            modal.getRoot().on(\n                ModalEvents.cancel,\n                () => {\n                    resolve(null);\n                }\n            );\n        });\n    }\n\n    /**\n     * Create a new modal and return a Promise to the body rendered.\n     *\n     * @param {Object} modalParams the modal params\n     * @returns {Promise} the modal body rendered promise\n     */\n    modalBodyRenderedPromise(modalParams) {\n        return new Promise((resolve, reject) => {\n            ModalSaveCancel.create(modalParams).then((modal) => {\n                modal.setRemoveOnClose(true);\n                // Handle body loading event.\n                modal.getRoot().on(ModalEvents.bodyRendered, () => {\n                    resolve(modal);\n                });\n                // Configure some extra modal params.\n                if (modalParams.saveButtonText !== undefined) {\n                    modal.setSaveButtonText(modalParams.saveButtonText);\n                }\n                modal.show();\n                return;\n            }).catch(() => {\n                reject(`Cannot load modal content`);\n            });\n        });\n    }\n}\n\n/**\n * Add a section to refresh.\n *\n * @param {number} courseId the course id\n * @param {number} sectionId the seciton id\n */\nfunction addRefreshSection(courseId, sectionId) {\n    let refresh = courseUpdates.get(courseId);\n    if (!refresh) {\n        refresh = new Set();\n    }\n    refresh.add(sectionId);\n    courseUpdates.set(courseId, refresh);\n    refreshCourseEditors();\n}\n\n/**\n * Debounced processing all pending course refreshes.\n * @private\n */\nconst refreshCourseEditors = debounce(\n    () => {\n        const refreshes = courseUpdates;\n        courseUpdates = new Map();\n        refreshes.forEach((sectionIds, courseId) => {\n            const courseEditor = getCourseEditor(courseId);\n            if (!courseEditor) {\n                return;\n            }\n            courseEditor.dispatch('sectionState', [...sectionIds]);\n        });\n    },\n    DEBOUNCETIMER\n);\n\n/**\n * Load and return the course handler manager instance.\n *\n * @param {Number} courseId the course Id to load\n * @returns {Promise<HandlerManager>} promise of the the loaded handleManager\n */\nasync function loadCourseHandlerManager(courseId) {\n    if (handlerManagers[courseId] !== undefined) {\n        return handlerManagers[courseId];\n    }\n    const handlerManager = new HandlerManager(courseId);\n    await handlerManager.loadHandlers();\n    handlerManagers[courseId] = handlerManager;\n    return handlerManagers[courseId];\n}\n\n/**\n * Load all the erros messages at once in the module \"errors\" variable.\n * @param {Number} courseId the course id\n */\nasync function loadErrorStrings(courseId) {\n    if (errors !== null) {\n        return;\n    }\n    const courseEditor = getCourseEditor(courseId);\n    const maxbytestext = courseEditor.get('course')?.maxbytestext ?? '0';\n\n    errors = {};\n    const allStrings = [\n        {key: 'dndmaxbytes', component: 'core_error', param: {size: maxbytestext}},\n        {key: 'dndread', component: 'core_error'},\n        {key: 'dndupload', component: 'core_error'},\n        {key: 'dndunkownfile', component: 'core_error'},\n    ];\n    window.console.log(allStrings);\n    const loadedStrings = await getStrings(allStrings);\n    allStrings.forEach(({key}, index) => {\n        errors[key] = loadedStrings[index];\n    });\n}\n\n/**\n * Start a batch file uploading into the course.\n *\n * @private\n * @param {number} courseId the course id.\n * @param {number} sectionId the section id.\n * @param {number} sectionNum the section number.\n * @param {File} fileInfo the file information object\n * @param {HandlerManager} handlerManager the course handler manager\n */\nconst queueFileUpload = async function(courseId, sectionId, sectionNum, fileInfo, handlerManager) {\n    let handler;\n    uploadQueue = await processMonitor.createProcessQueue();\n    try {\n        handlerManager.validateFile(fileInfo);\n        handler = await handlerManager.getFileHandler(fileInfo);\n    } catch (error) {\n        uploadQueue.addError(fileInfo.name, error.message);\n        return;\n    }\n    // If we don't have a handler means the user cancel the upload.\n    if (!handler) {\n        return;\n    }\n    const fileProcessor = new FileUploader(courseId, sectionId, sectionNum, fileInfo, handler);\n    uploadQueue.addPending(fileInfo.name, fileProcessor.getExecutionFunction());\n};\n\n/**\n * Upload a file to the course.\n *\n * This method will show any necesary modal to handle the request.\n *\n * @param {number} courseId the course id\n * @param {number} sectionId the section id\n * @param {number} sectionNum the section number\n * @param {Array} files and array of files\n */\nexport const uploadFilesToCourse = async function(courseId, sectionId, sectionNum, files) {\n    // Get the course handlers.\n    const handlerManager = await loadCourseHandlerManager(courseId);\n    await loadErrorStrings(courseId);\n    for (let index = 0; index < files.length; index++) {\n        const fileInfo = files[index];\n        await queueFileUpload(courseId, sectionId, sectionNum, fileInfo, handlerManager);\n    }\n};\n"],"names":["_interopRequireDefault","obj","__esModule","default","_config","_modal_save_cancel","_modal_events","_templates","UPLOADURL","Config","wwwroot","uploadQueue","handlerManagers","courseUpdates","Map","errors","prefetchStrings","FileUploader","constructor","courseId","sectionId","sectionNum","fileInfo","handler","this","execute","process","xhr","_createXhrRequest","formData","_createUploadFormData","reader","FileReader","onload","open","send","onerror","setError","dndread","size","readAsText","slice","getExecutionFunction","bind","XMLHttpRequest","upload","addEventListener","event","lengthComputable","percent","Math","round","loaded","total","setPercentage","onreadystatechange","readyState","status","result","JSON","parse","responseText","error","_finishProcess","dndupload","FormData","append","Error","sesskey","module","refresh","get","Set","add","set","refreshCourseEditors","addRefreshSection","finish","HandlerManager","lastHandlers","allHandlers","_this$courseEditor$ge","lastUploadId","courseEditor","getCourseEditor","maxbytes","loadHandlers","getFileHandlersPromise","getFileExtension","extension","dotpos","name","lastIndexOf","substring","length","toLowerCase","validateFile","dndmaxbytes","filterHandlers","filter","getFileHandler","fileHandlers","dndunkownfile","fileHandler","askHandlerToUser","modalParams","title","getString","body","Templates","render","getModalData","saveButtonText","modal","modalBodyRenderedPromise","selectedHandler","modalUserAnswerPromise","defaultModule","data","filename","uploadid","handlers","hasDefault","forEach","index","isDefault","push","selected","labelid","value","lastHandler","pop","modalBody","getFirst","getBody","Promise","resolve","reject","getRoot","on","ModalEvents","save","querySelector","preventDefault","destroy","cancel","ModalSaveCancel","create","then","setRemoveOnClose","bodyRendered","undefined","setSaveButtonText","show","catch","debounce","refreshes","sectionIds","dispatch","queueFileUpload","async","handlerManager","processMonitor","createProcessQueue","addError","message","fileProcessor","addPending","_exports","uploadFilesToCourse","files","loadCourseHandlerManager","_courseEditor$get","maxbytestext","allStrings","key","component","param","window","console","log","loadedStrings","getStrings","_ref","loadErrorStrings"],"mappings":"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"}