{"version":3,"file":"datafilter.min.js","sources":["../src/datafilter.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Data filter management.\n *\n * @module     core/datafilter\n * @copyright  2020 Andrew Nicols <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport CourseFilter from 'core/datafilter/filtertypes/courseid';\nimport GenericFilter from 'core/datafilter/filtertype';\nimport {getStrings} from 'core/str';\nimport Notification from 'core/notification';\nimport Pending from 'core/pending';\nimport Selectors from 'core/datafilter/selectors';\nimport Templates from 'core/templates';\nimport CustomEvents from 'core/custom_interaction_events';\nimport jQuery from 'jquery';\n\nexport default class {\n\n    /**\n     * Initialise the filter on the element with the given filterSet and callback.\n     *\n     * @param {HTMLElement} filterSet The filter element.\n     * @param {Function} applyCallback Callback function when updateTableFromFilter\n     */\n    constructor(filterSet, applyCallback) {\n\n        this.filterSet = filterSet;\n        this.applyCallback = applyCallback;\n        // Keep a reference to all of the active filters.\n        this.activeFilters = {\n            courseid: new CourseFilter('courseid', filterSet),\n        };\n    }\n\n    /**\n     * Initialise event listeners to the filter.\n     */\n    init() {\n        // Add listeners for the main actions.\n        this.filterSet.querySelector(Selectors.filterset.region).addEventListener('click', e => {\n            if (e.target.closest(Selectors.filterset.actions.addRow)) {\n                e.preventDefault();\n\n                this.addFilterRow();\n            }\n\n            if (e.target.closest(Selectors.filterset.actions.applyFilters)) {\n                e.preventDefault();\n\n                this.updateTableFromFilter();\n            }\n\n            if (e.target.closest(Selectors.filterset.actions.resetFilters)) {\n                e.preventDefault();\n\n                this.removeAllFilters();\n            }\n        });\n\n        // Add the listener to remove a single filter.\n        this.filterSet.querySelector(Selectors.filterset.regions.filterlist).addEventListener('click', e => {\n            if (e.target.closest(Selectors.filter.actions.remove)) {\n                e.preventDefault();\n\n                this.removeOrReplaceFilterRow(e.target.closest(Selectors.filter.region), true);\n            }\n        });\n\n        // Add listeners for the filter type selection.\n        let filterRegion = jQuery(this.getFilterRegion());\n        CustomEvents.define(filterRegion, [CustomEvents.events.accessibleChange]);\n        filterRegion.on(CustomEvents.events.accessibleChange, e => {\n            const typeField = e.target.closest(Selectors.filter.fields.type);\n            if (typeField && typeField.value) {\n                const filter = e.target.closest(Selectors.filter.region);\n\n                this.addFilter(filter, typeField.value);\n            }\n        });\n\n        this.filterSet.querySelector(Selectors.filterset.fields.join).addEventListener('change', e => {\n            this.filterSet.dataset.filterverb = e.target.value;\n        });\n    }\n\n    /**\n     * Get the filter list region.\n     *\n     * @return {HTMLElement}\n     */\n    getFilterRegion() {\n        return this.filterSet.querySelector(Selectors.filterset.regions.filterlist);\n    }\n\n    /**\n     * Add a filter row.\n     *\n     * @param {Object} filterdata Optional, data for adding for row with an existing filter.\n     * @return {Promise}\n     */\n    addFilterRow(filterdata = {}) {\n        const pendingPromise = new Pending('core/datafilter:addFilterRow');\n        const rownum = filterdata.rownum ?? 1 + this.getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n        return Templates.renderForPromise('core/datafilter/filter_row', {\"rownumber\": rownum})\n            .then(({html, js}) => {\n                const newContentNodes = Templates.appendNodeContents(this.getFilterRegion(), html, js);\n\n                return newContentNodes;\n            })\n            .then(filterRow => {\n                // Note: This is a nasty hack.\n                // We should try to find a better way of doing this.\n                // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                // it in place.\n                const typeList = this.filterSet.querySelector(Selectors.data.typeList);\n\n                filterRow.forEach(contentNode => {\n                    const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n\n                    if (contentTypeList) {\n                        contentTypeList.innerHTML = typeList.innerHTML;\n                    }\n                });\n\n                return filterRow;\n            })\n            .then(filterRow => {\n                this.updateFiltersOptions();\n\n                return filterRow;\n            })\n            .then(result => {\n                pendingPromise.resolve();\n\n                // If an existing filter is passed in, add it. Otherwise, leave the row empty.\n                if (filterdata.filtertype) {\n                    result.forEach(filter => {\n                        this.addFilter(filter, filterdata.filtertype, filterdata.values,\n                            filterdata.jointype, filterdata.filteroptions);\n                    });\n                }\n                return result;\n            })\n            .catch(Notification.exception);\n    }\n\n    /**\n     * Get the filter data source node fro the specified filter type.\n     *\n     * @param {String} filterType\n     * @return {HTMLElement}\n     */\n    getFilterDataSource(filterType) {\n        const filterDataNode = this.filterSet.querySelector(Selectors.filterset.regions.datasource);\n\n        return filterDataNode.querySelector(Selectors.data.fields.byName(filterType));\n    }\n\n    /**\n     * Add a filter to the list of active filters, performing any necessary setup.\n     *\n     * @param {HTMLElement} filterRow\n     * @param {String} filterType\n     * @param {Array} initialFilterValues The initially selected values for the filter\n     * @param {String} filterJoin\n     * @param {Object} filterOptions\n     * @returns {Filter}\n     */\n    async addFilter(filterRow, filterType, initialFilterValues, filterJoin, filterOptions) {\n        // Name the filter on the filter row.\n        filterRow.dataset.filterType = filterType;\n\n        const filterDataNode = this.getFilterDataSource(filterType);\n\n        // Instantiate the Filter class.\n        let Filter = GenericFilter;\n        if (filterDataNode.dataset.filterTypeClass) {\n            Filter = await import(filterDataNode.dataset.filterTypeClass);\n        }\n        this.activeFilters[filterType] = new Filter(filterType, this.filterSet, initialFilterValues, filterOptions);\n\n        // Disable the select.\n        const typeField = filterRow.querySelector(Selectors.filter.fields.type);\n        typeField.value = filterType;\n        typeField.disabled = 'disabled';\n        // Update the join list.\n        this.updateJoinList(JSON.parse(filterDataNode.dataset.joinList), filterRow);\n        const joinField = filterRow.querySelector(Selectors.filter.fields.join);\n        if (!isNaN(filterJoin)) {\n            joinField.value = filterJoin;\n        }\n        // Update the list of available filter types.\n        this.updateFiltersOptions();\n\n        return this.activeFilters[filterType];\n    }\n\n    /**\n     * Get the registered filter class for the named filter.\n     *\n     * @param {String} name\n     * @return {Object} See the Filter class.\n     */\n    getFilterObject(name) {\n        return this.activeFilters[name];\n    }\n\n    /**\n     * Remove or replace the specified filter row and associated class, ensuring that if there is only one filter row,\n     * that it is replaced instead of being removed.\n     *\n     * @param {HTMLElement} filterRow\n     * @param {Bool} refreshContent Whether to refresh the table content when removing\n     */\n    removeOrReplaceFilterRow(filterRow, refreshContent) {\n        const filterCount = this.getFilterRegion().querySelectorAll(Selectors.filter.region).length;\n        if (filterCount === 1) {\n            this.replaceFilterRow(filterRow, refreshContent);\n        } else {\n            this.removeFilterRow(filterRow, refreshContent);\n        }\n    }\n\n    /**\n     * Remove the specified filter row and associated class.\n     *\n     * @param {HTMLElement} filterRow\n     * @param {Bool} refreshContent Whether to refresh the table content when removing\n     */\n    async removeFilterRow(filterRow, refreshContent = true) {\n        if (filterRow.querySelector(Selectors.data.required)) {\n            return;\n        }\n        const filterType = filterRow.querySelector(Selectors.filter.fields.type);\n        const hasFilterValue = !!filterType.value;\n\n        // Remove the filter object.\n        this.removeFilterObject(filterRow.dataset.filterType);\n\n        // Remove the actual filter HTML.\n        filterRow.remove();\n\n        // Update the list of available filter types.\n        this.updateFiltersOptions();\n\n        if (hasFilterValue && refreshContent) {\n            // Refresh the table if there was any content in this row.\n            this.updateTableFromFilter();\n        }\n\n        // Update filter fieldset legends.\n        const filterLegends = await this.getAvailableFilterLegends();\n\n        this.getFilterRegion().querySelectorAll(Selectors.filter.region).forEach((filterRow, index) => {\n            filterRow.querySelector('legend').innerText = filterLegends[index];\n        });\n\n    }\n\n    /**\n     * Replace the specified filter row with a new one.\n     *\n     * @param {HTMLElement} filterRow\n     * @param {Bool} refreshContent Whether to refresh the table content when removing\n     * @param {Number} rowNum The number used to label the filter fieldset legend (eg Row 1). Defaults to 1 (the first filter).\n     * @return {Promise}\n     */\n    replaceFilterRow(filterRow, refreshContent = true, rowNum = 1) {\n        if (filterRow.querySelector(Selectors.data.required)) {\n            return;\n        }\n        // Remove the filter object.\n        this.removeFilterObject(filterRow.dataset.filterType);\n\n        return Templates.renderForPromise('core/datafilter/filter_row', {\"rownumber\": rowNum})\n            .then(({html, js}) => {\n                const newContentNodes = Templates.replaceNode(filterRow, html, js);\n\n                return newContentNodes;\n            })\n            .then(filterRow => {\n                // Note: This is a nasty hack.\n                // We should try to find a better way of doing this.\n                // We do not have the list of types in a readily consumable format, so we take the pre-rendered one and copy\n                // it in place.\n                const typeList = this.filterSet.querySelector(Selectors.data.typeList);\n\n                filterRow.forEach(contentNode => {\n                    const contentTypeList = contentNode.querySelector(Selectors.filter.fields.type);\n\n                    if (contentTypeList) {\n                        contentTypeList.innerHTML = typeList.innerHTML;\n                    }\n                });\n\n                return filterRow;\n            })\n            .then(filterRow => {\n                this.updateFiltersOptions();\n\n                return filterRow;\n            })\n            .then(filterRow => {\n                // Refresh the table.\n                if (refreshContent) {\n                    return this.updateTableFromFilter();\n                } else {\n                    return filterRow;\n                }\n            })\n            .catch(Notification.exception);\n    }\n\n    /**\n     * Remove the Filter Object from the register.\n     *\n     * @param {string} filterName The name of the filter to be removed\n     */\n    removeFilterObject(filterName) {\n        if (filterName) {\n            const filter = this.getFilterObject(filterName);\n            if (filter) {\n                filter.tearDown();\n\n                // Remove from the list of active filters.\n                delete this.activeFilters[filterName];\n            }\n        }\n    }\n\n    /**\n     * Remove all filters.\n     *\n     * @returns {Promise}\n     */\n    removeAllFilters() {\n        const filters = this.getFilterRegion().querySelectorAll(Selectors.filter.region);\n        filters.forEach(filterRow => this.removeOrReplaceFilterRow(filterRow, false));\n\n        // Refresh the table.\n        return this.updateTableFromFilter();\n    }\n\n    /**\n     * Remove any empty filters.\n     */\n    removeEmptyFilters() {\n        const filters = this.getFilterRegion().querySelectorAll(Selectors.filter.region);\n        filters.forEach(filterRow => {\n            const filterType = filterRow.querySelector(Selectors.filter.fields.type);\n            if (!filterType.value) {\n                this.removeOrReplaceFilterRow(filterRow, false);\n            }\n        });\n    }\n\n    /**\n     * Update the list of filter types to filter out those already selected.\n     */\n    updateFiltersOptions() {\n        const filters = this.getFilterRegion().querySelectorAll(Selectors.filter.region);\n        filters.forEach(filterRow => {\n            const options = filterRow.querySelectorAll(Selectors.filter.fields.type + ' option');\n            options.forEach(option => {\n                if (option.value === filterRow.dataset.filterType) {\n                    option.classList.remove('hidden');\n                    option.disabled = false;\n                } else if (this.activeFilters[option.value]) {\n                    option.classList.add('hidden');\n                    option.disabled = true;\n                } else {\n                    option.classList.remove('hidden');\n                    option.disabled = false;\n                }\n            });\n        });\n\n        // Configure the state of the \"Add row\" button.\n        // This button is disabled when there is a filter row available for each condition.\n        const addRowButton = this.filterSet.querySelector(Selectors.filterset.actions.addRow);\n        const filterDataNode = this.filterSet.querySelectorAll(Selectors.data.fields.all);\n        if (filterDataNode.length <= filters.length) {\n            addRowButton.setAttribute('disabled', 'disabled');\n        } else {\n            addRowButton.removeAttribute('disabled');\n        }\n\n        if (filters.length === 1) {\n            this.filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.add('hidden');\n            this.filterSet.querySelector(Selectors.filterset.fields.join).value = 2;\n            this.filterSet.dataset.filterverb = 2;\n        } else {\n            this.filterSet.querySelector(Selectors.filterset.regions.filtermatch).classList.remove('hidden');\n        }\n    }\n\n    /**\n     * Update the Dynamic table based upon the current filter.\n     */\n    updateTableFromFilter() {\n        const pendingPromise = new Pending('core/datafilter:updateTableFromFilter');\n\n        const filters = {};\n        Object.values(this.activeFilters).forEach(filter => {\n            filters[filter.filterValue.name] = filter.filterValue;\n        });\n\n        if (this.applyCallback) {\n            this.applyCallback(filters, pendingPromise);\n        }\n    }\n\n    /**\n     * Fetch the strings used to populate the fieldset legends for the maximum number of filters possible.\n     *\n     * @return {array}\n     */\n    async getAvailableFilterLegends() {\n        const maxFilters = document.querySelector(Selectors.data.typeListSelect).length - 1;\n        let requests = [];\n\n        [...Array(maxFilters)].forEach((_, rowIndex) => {\n            requests.push({\n                \"key\": \"filterrowlegend\",\n                \"component\": \"core\",\n                // Add 1 since rows begin at 1 (index begins at zero).\n                \"param\": rowIndex + 1\n            });\n        });\n\n        const legendStrings = await getStrings(requests)\n            .then(fetchedStrings => {\n                return fetchedStrings;\n            })\n            .catch(Notification.exception);\n\n        return legendStrings;\n    }\n\n    /**\n     * Update the list of join types for a filter.\n     *\n     * This will update the list of join types based on the allowed types defined for a filter.\n     * If only one type is allowed, the list will be hidden.\n     *\n     * @param {Array} filterJoinList Array of join types, a subset of the regularJoinList array in this function.\n     * @param {Element} filterRow The row being updated.\n     */\n    updateJoinList(filterJoinList, filterRow) {\n        const regularJoinList = [0, 1, 2];\n        // If a join list was specified for this filter, find the default join list and disable the options that are not allowed\n        // for this filter.\n        if (filterJoinList.length !== 0) {\n            const joinField = filterRow.querySelector(Selectors.filter.fields.join);\n            // Check each option from the default list, and disable the option in this filter row if it is not allowed\n            // for this filter.\n            regularJoinList.forEach((join) => {\n                if (!filterJoinList.includes(join)) {\n                    joinField.options[join].classList.add('hidden');\n                    joinField.options[join].disabled = true;\n                }\n            });\n            // Now remove the disabled options, and hide the select list of there is only one option left.\n            joinField.options.forEach((element, index) => {\n                if (element.disabled) {\n                    joinField.options[index] = null;\n                }\n            });\n            if (joinField.options.length === 1) {\n                joinField.hidden = true;\n            }\n        }\n    }\n}\n"],"names":["_courseid","_interopRequireDefault","_filtertype","_notification","_pending","_selectors","_templates","_custom_interaction_events","_jquery","_systemImportTransformerGlobalIdentifier","window","self","global","obj","__esModule","default","_exports","constructor","filterSet","applyCallback","this","activeFilters","courseid","CourseFilter","init","querySelector","Selectors","filterset","region","addEventListener","e","target","closest","actions","addRow","preventDefault","addFilterRow","applyFilters","updateTableFromFilter","resetFilters","removeAllFilters","regions","filterlist","filter","remove","removeOrReplaceFilterRow","filterRegion","jQuery","getFilterRegion","CustomEvents","define","events","accessibleChange","on","typeField","fields","type","value","addFilter","join","dataset","filterverb","filterdata","arguments","length","undefined","pendingPromise","Pending","rownum","querySelectorAll","Templates","renderForPromise","rownumber","then","_ref","html","js","appendNodeContents","filterRow","typeList","data","forEach","contentNode","contentTypeList","innerHTML","updateFiltersOptions","result","resolve","filtertype","values","jointype","filteroptions","catch","Notification","exception","getFilterDataSource","filterType","datasource","byName","initialFilterValues","filterJoin","filterOptions","filterDataNode","Filter","GenericFilter","filterTypeClass","amd","Promise","reject","require","module","exports","component","loader","disabled","updateJoinList","JSON","parse","joinList","joinField","isNaN","getFilterObject","name","refreshContent","replaceFilterRow","removeFilterRow","required","hasFilterValue","removeFilterObject","filterLegends","getAvailableFilterLegends","index","innerText","rowNum","_ref2","replaceNode","filterName","tearDown","removeEmptyFilters","filters","option","classList","add","addRowButton","all","setAttribute","removeAttribute","filtermatch","Object","filterValue","maxFilters","document","typeListSelect","requests","Array","_","rowIndex","push","key","param","getStrings","fetchedStrings","filterJoinList","regularJoinList","includes","options","element","hidden"],"mappings":"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"}