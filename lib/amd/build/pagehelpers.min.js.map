{"version":3,"file":"pagehelpers.min.js","sources":["../src/pagehelpers.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Page utility helpers.\n *\n * @module core/pagehelpers\n * @copyright  2023 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n/**\n * Maximum sizes for breakpoints. This needs to correspond with Bootstrap\n * Breakpoints\n *\n * @private\n */\nconst Sizes = {\n    small: 576,\n    medium: 991,\n    large: 1400\n};\n\nconst Selectors = {\n    focusable: 'a, button, input, select, textarea, [tabindex]:not([tabindex=\"-1\"])',\n};\n\nconst Classes = {\n    behatSite: 'behat-site',\n};\n\n/**\n * Check fi the current page is a Behat site.\n * @returns {boolean} true if the current page is a Behat site.\n */\nexport const isBehatSite = () => {\n    return document.body.classList.contains(Classes.behatSite);\n};\n\n/**\n * Get the current body width.\n * @returns {number} the current body width.\n */\nexport const getCurrentWidth = () => {\n    const DomRect = document.body.getBoundingClientRect();\n    return DomRect.x + DomRect.width;\n};\n\n/**\n * Check if the user uses an extra small size browser.\n *\n * @returns {boolean} true if the body is smaller than sizes.small max size.\n */\nexport const isExtraSmall = () => {\n    const browserWidth = getCurrentWidth();\n    return browserWidth < Sizes.small;\n};\n\n/**\n * Check if the user uses a small size browser.\n *\n * @returns {boolean} true if the body is smaller than sizes.medium max size.\n */\nexport const isSmall = () => {\n    const browserWidth = getCurrentWidth();\n    return browserWidth < Sizes.medium;\n};\n\n/**\n * Check if the user uses a large size browser.\n *\n * @returns {boolean} true if the body is smaller than sizes.large max size.\n */\nexport const isLarge = () => {\n    const browserWidth = getCurrentWidth();\n    return browserWidth >= Sizes.large;\n};\n\n/**\n * Get the first focusable element inside a container.\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\n * @returns {HTMLElement|null}\n */\nexport const firstFocusableElement = (container) => {\n    const containerElement = container || document;\n    return containerElement.querySelector(Selectors.focusable);\n};\n\n/**\n * Get the last focusable element inside a container.\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\n * @returns {HTMLElement|null}\n */\nexport const lastFocusableElement = (container) => {\n    const containerElement = container || document;\n    const focusableElements = containerElement.querySelectorAll(Selectors.focusable);\n    return focusableElements[focusableElements.length - 1] ?? null;\n};\n\n/**\n * Get all focusable elements inside a container.\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\n * @returns {HTMLElement[]}\n */\nexport const focusableElements = (container) => {\n    const containerElement = container || document;\n    return containerElement.querySelectorAll(Selectors.focusable);\n};\n\n/**\n * Get the previous focusable element in a container.\n * It uses the current focused element to know where to start the search.\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\n * @param {Boolean} [loopSelection] Whether to loop selection or not. Default to false.\n * @returns {HTMLElement|null}\n */\nexport const previousFocusableElement = (container, loopSelection) => {\n    return getRelativeFocusableElement(container, loopSelection, -1);\n};\n\n/**\n * Get the next focusable element in a container.\n * It uses the current focused element to know where to start the search.\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\n * @param {Boolean} [loopSelection] Whether to loop selection or not. Default to false.\n * @returns {HTMLElement|null}\n */\nexport const nextFocusableElement = (container, loopSelection) => {\n    return getRelativeFocusableElement(container, loopSelection, 1);\n};\n\n/**\n * Internal function to get the next or previous focusable element.\n * @param {HTMLElement} [container] Container to search in. Defaults to document.\n * @param {Boolean} [loopSelection] Whether to loop selection or not.\n * @param {Number} [direction] Direction to search in. 1 for next, -1 for previous.\n * @returns {HTMLElement|null}\n * @private\n */\nconst getRelativeFocusableElement = (container, loopSelection, direction) => {\n    const focusedElement = document.activeElement;\n    const focusables = [...focusableElements(container)];\n    const focusedIndex = focusables.indexOf(focusedElement);\n\n    if (focusedIndex === -1) {\n        return null;\n    }\n\n    const newIndex = focusedIndex + direction;\n\n    if (focusables[newIndex] !== undefined) {\n        return focusables[newIndex];\n    }\n    if (loopSelection != true) {\n        return null;\n    }\n    if (direction > 0) {\n        return focusables[0] ?? null;\n    }\n    return focusables[focusables.length - 1] ?? null;\n};\n"],"names":["Sizes","Selectors","Classes","_exports","isBehatSite","document","body","classList","contains","getCurrentWidth","DomRect","getBoundingClientRect","x","width","isExtraSmall","isSmall","isLarge","firstFocusableElement","container","querySelector","lastFocusableElement","focusableElements","querySelectorAll","length","previousFocusableElement","loopSelection","getRelativeFocusableElement","nextFocusableElement","direction","focusedElement","activeElement","focusables","focusedIndex","indexOf","newIndex","undefined"],"mappings":";;;;;;;;AA6BA,MAAMA,YACK,IADLA,aAEM,IAFNA,YAGK,KAGLC,oBACS,sEAGTC,kBACS,aASbC,SAAAC,YAFyBA,IAChBC,SAASC,KAAKC,UAAUC,SAASN,mBAOrC,MAAMO,gBAAkBA,KAC3B,MAAMC,QAAUL,SAASC,KAAKK,wBAC9B,OAAOD,QAAQE,EAAIF,QAAQG,KAAK,EAClCV,SAAAM,gBAAAA,gBAUAN,SAAAW,aAH0BA,IACHL,kBACCT,YAWxBG,SAAAY,QAHqBA,IACEN,kBACCT,aAWxBG,SAAAa,QAHqBA,IACEP,mBACET,YAWzBG,SAAAc,sBAHoCC,YACTA,WAAab,UACdc,cAAclB,qBAYxCE,SAAAiB,qBAJmCF,YACjC,MACMG,mBADmBH,WAAab,UACKiB,iBAAiBrB,qBAC5D,OAAOoB,kBAAkBA,kBAAkBE,OAAS,IAAM,IAAI,EAQ3D,MAAMF,kBAAqBH,YACLA,WAAab,UACdiB,iBAAiBrB,qBAC3CE,SAAAkB,kBAAAA,kBAWAlB,SAAAqB,yBAFsCA,CAACN,UAAWO,gBACzCC,4BAA4BR,UAAWO,eAAgB,GAYhEtB,SAAAwB,qBAFkCA,CAACT,UAAWO,gBACrCC,4BAA4BR,UAAWO,cAAe,GAWjE,MAAMC,4BAA8BA,CAACR,UAAWO,cAAeG,aAC3D,MAAMC,eAAiBxB,SAASyB,cAC1BC,WAAa,IAAIV,kBAAkBH,YACnCc,aAAeD,WAAWE,QAAQJ,gBAExC,IAAsB,IAAlBG,aACA,OAAO,KAGX,MAAME,SAAWF,aAAeJ,UAEhC,YAA6BO,IAAzBJ,WAAWG,UACJH,WAAWG,UAED,GAAjBT,cACO,KAEPG,UAAY,EACLG,WAAW,IAAM,KAErBA,WAAWA,WAAWR,OAAS,IAAM,IAAI,CAClD"}