{"version":3,"file":"filtertype.min.js","sources":["../../src/datafilter/filtertype.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Base Filter class for a filter type in the filter UI.\n *\n * @module     core/datafilter/filtertype\n * @copyright  2020 Andrew Nicols <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport Autocomplete from 'core/form-autocomplete';\nimport Selectors from 'core/datafilter/selectors';\nimport {getString} from 'core/str';\nimport Notification from 'core/notification';\n\n/**\n * Fetch all checked options in the select.\n *\n * This is a poor-man's polyfill for select.selectedOptions, which is not available in IE11.\n *\n * @param {HTMLSelectElement} select\n * @returns {HTMLOptionElement[]} All selected options\n */\nconst getOptionsForSelect = select => {\n    return select.querySelectorAll(':checked');\n};\n\nexport default class {\n\n    /**\n     * Constructor for a new filter.\n     *\n     * @param {String} filterType The type of filter that this relates to\n     * @param {HTMLElement} rootNode The root node for the participants filterset\n     * @param {Array} initialValues The initial values for the selector\n     */\n    constructor(filterType, rootNode, initialValues) {\n        this.filterType = filterType;\n        this.rootNode = rootNode;\n\n        this.addValueSelector(initialValues).then(() => {\n            const filterRoot = this.filterRoot;\n            if (filterRoot && filterRoot.querySelector(Selectors.data.required)) {\n                filterRoot.querySelector(Selectors.filter.actions.remove).remove();\n            }\n            return filterRoot;\n        }).catch(Notification.exception);\n\n    }\n\n    /**\n     * Perform any tear-down for this filter type.\n     */\n    tearDown() {\n        // eslint-disable-line no-empty-function\n    }\n\n    /**\n     * Get the placeholder to use when showing the value selector.\n     *\n     * @return {Promise} Resolving to a String\n     */\n    get placeholder() {\n        return getString('placeholdertypeorselect', 'core');\n    }\n\n    /**\n     * Whether to show suggestions in the autocomplete.\n     *\n     * @return {Boolean}\n     */\n    get showSuggestions() {\n        return true;\n    }\n\n    /**\n     * Add the value selector to the filter row.\n     *\n     * @param {Array} initialValues\n     * @return {Promise}\n     */\n    async addValueSelector(initialValues = []) {\n        const filterValueNode = this.getFilterValueNode();\n\n        // Copy the data in place.\n        const sourceDataNode = this.getSourceDataForFilter();\n        if (!sourceDataNode) {\n            throw new Error('No source data for filter.');\n        }\n        filterValueNode.innerHTML = sourceDataNode.outerHTML;\n\n        const dataSource = filterValueNode.querySelector('select');\n\n        // Set an ID for this filter value element.\n        dataSource.id = 'filter-value-' + dataSource.getAttribute('data-field-name');\n\n        // Create a hidden label for the filter value.\n        const filterValueLabel = document.createElement('label');\n        filterValueLabel.setAttribute('for', dataSource.id);\n        filterValueLabel.classList.add('sr-only');\n        filterValueLabel.innerText = dataSource.getAttribute('data-field-title');\n\n        // Append this label to the filter value container.\n        filterValueNode.appendChild(filterValueLabel);\n\n        // If there are any initial values then attempt to apply them.\n        initialValues.forEach(filterValue => {\n            let selectedOption = dataSource.querySelector(`option[value=\"${filterValue}\"]`);\n            if (selectedOption) {\n                selectedOption.selected = true;\n            } else if (!this.showSuggestions) {\n                selectedOption = document.createElement('option');\n                selectedOption.value = filterValue;\n                selectedOption.innerHTML = filterValue;\n                selectedOption.selected = true;\n\n                dataSource.append(selectedOption);\n            }\n        });\n\n        return Autocomplete.enhance(\n            // The source select element.\n            dataSource,\n\n            // Whether to allow 'tags' (custom entries).\n            dataSource.dataset.allowCustom == \"1\",\n\n            // We do not require AJAX at all as standard.\n            null,\n\n            // The string to use as a placeholder.\n            await this.placeholder,\n\n            // Disable case sensitivity on searches.\n            false,\n\n            // Show suggestions.\n            this.showSuggestions,\n\n            // Do not override the 'no suggestions' string.\n            null,\n\n            // Close the suggestions if this is not a multi-select.\n            !dataSource.multiple,\n\n            // Template overrides.\n            {\n                items: 'core/datafilter/autocomplete_selection_items',\n                layout: 'core/datafilter/autocomplete_layout',\n                selection: 'core/datafilter/autocomplete_selection',\n            }\n        );\n    }\n\n    /**\n     * Get the root node for this filter.\n     *\n     * @returns {HTMLElement}\n     */\n    get filterRoot() {\n        return this.rootNode.querySelector(Selectors.filter.byName(this.filterType));\n    }\n\n    /**\n     * Get the possible data for this filter type.\n     *\n     * @returns {Array}\n     */\n    getSourceDataForFilter() {\n        const filterDataNode = this.rootNode.querySelector(Selectors.filterset.regions.datasource);\n\n        return filterDataNode.querySelector(Selectors.data.fields.byName(this.filterType));\n    }\n\n    /**\n     * Get the HTMLElement which contains the value selector.\n     *\n     * @returns {HTMLElement}\n     */\n    getFilterValueNode() {\n        return this.filterRoot.querySelector(Selectors.filter.regions.values);\n    }\n\n    /**\n     * Get the name of this filter.\n     *\n     * @returns {String}\n     */\n    get name() {\n        return this.filterType;\n    }\n\n    /**\n     * Get the type of join specified.\n     *\n     * @returns {Number}\n     */\n    get jointype() {\n        return parseInt(this.filterRoot.querySelector(Selectors.filter.fields.join).value, 10);\n    }\n\n    /**\n     * Get the list of raw values for this filter type.\n     *\n     * @returns {Array}\n     */\n    get rawValues() {\n        const filterValueNode = this.getFilterValueNode();\n        const filterValueSelect = filterValueNode.querySelector('select');\n\n        return Object.values(getOptionsForSelect(filterValueSelect)).map(option => option.value);\n    }\n\n    /**\n     * Get the list of values for this filter type.\n     *\n     * @returns {Array}\n     */\n    get values() {\n        return this.rawValues.map(option => parseInt(option, 10));\n    }\n\n    /**\n     * Get options specific to this filter type.\n     *\n     * @returns {Array} of {name:, value:} objects\n     */\n    get filterOptions() {\n        return [];\n    }\n\n    /**\n     * Get the composed value for this filter.\n     *\n     * @returns {Object}\n     */\n    get filterValue() {\n        return {\n            name: this.name,\n            jointype: this.jointype,\n            values: this.values,\n            filteroptions: this.filterOptions,\n        };\n    }\n}\n"],"names":["_interopRequireDefault","obj","__esModule","default","_formAutocomplete","_selectors","_notification","_exports","constructor","filterType","rootNode","initialValues","this","addValueSelector","then","filterRoot","querySelector","Selectors","data","required","filter","actions","remove","catch","Notification","exception","tearDown","placeholder","getString","showSuggestions","arguments","length","undefined","filterValueNode","getFilterValueNode","sourceDataNode","getSourceDataForFilter","Error","innerHTML","outerHTML","dataSource","id","getAttribute","filterValueLabel","document","createElement","setAttribute","classList","add","innerText","appendChild","forEach","filterValue","selectedOption","selected","value","append","Autocomplete","enhance","dataset","allowCustom","multiple","items","layout","selection","byName","filterset","regions","datasource","fields","values","name","jointype","parseInt","join","rawValues","filterValueSelect","Object","select","querySelectorAll","map","option","filterOptions","filteroptions"],"mappings":"wMAyB6C,SAAAA,uBAAAC,KAAAA,OAAAA,KAAAA,IAAAC,WAAAD,IAAAE,CAAAA,QAAAF,IAAA;;;;;;;qFAH7CG,kBAAAJ,uBAAAI,mBACAC,WAAAL,uBAAAK,YAEAC,cAAAN,uBAAAM,eAuOC,OAAAC,SAAAJ,QAzNc,MASXK,WAAAA,CAAYC,WAAYC,SAAUC,eAC9BC,KAAKH,WAAaA,WAClBG,KAAKF,SAAWA,SAEhBE,KAAKC,iBAAiBF,eAAeG,MAAK,KACtC,MAAMC,WAAaH,KAAKG,WAIxB,OAHIA,YAAcA,WAAWC,cAAcC,WAASd,QAACe,KAAKC,WACtDJ,WAAWC,cAAcC,WAAAA,QAAUG,OAAOC,QAAQC,QAAQA,SAEvDP,UAAU,IAClBQ,MAAMC,cAAYrB,QAACsB,UAE1B,CAKAC,QAAAA,GAEA,CAOA,eAAIC,GACA,OAAO,EAAAC,KAASA,WAAC,0BAA2B,OAChD,CAOA,mBAAIC,GACA,OAAO,CACX,CAQA,sBAAMhB,GAAqC,IAApBF,cAAamB,UAAAC,OAAA,QAAAC,IAAAF,UAAA,GAAAA,UAAA,GAAG,GACnC,MAAMG,gBAAkBrB,KAAKsB,qBAGvBC,eAAiBvB,KAAKwB,yBAC5B,IAAKD,eACD,MAAM,IAAIE,MAAM,8BAEpBJ,gBAAgBK,UAAYH,eAAeI,UAE3C,MAAMC,WAAaP,gBAAgBjB,cAAc,UAGjDwB,WAAWC,GAAK,gBAAkBD,WAAWE,aAAa,mBAG1D,MAAMC,iBAAmBC,SAASC,cAAc,SAuBhD,OAtBAF,iBAAiBG,aAAa,MAAON,WAAWC,IAChDE,iBAAiBI,UAAUC,IAAI,WAC/BL,iBAAiBM,UAAYT,WAAWE,aAAa,oBAGrDT,gBAAgBiB,YAAYP,kBAG5BhC,cAAcwC,SAAQC,cAClB,IAAIC,eAAiBb,WAAWxB,cAAe,iBAAgBoC,iBAC3DC,eACAA,eAAeC,UAAW,EAClB1C,KAAKiB,kBACbwB,eAAiBT,SAASC,cAAc,UACxCQ,eAAeE,MAAQH,YACvBC,eAAef,UAAYc,YAC3BC,eAAeC,UAAW,EAE1Bd,WAAWgB,OAAOH,gBACtB,IAGGI,kBAAYtD,QAACuD,QAEhBlB,WAGkC,KAAlCA,WAAWmB,QAAQC,YAGnB,WAGMhD,KAAKe,aAGX,EAGAf,KAAKiB,gBAGL,MAGCW,WAAWqB,SAGZ,CACIC,MAAO,+CACPC,OAAQ,sCACRC,UAAW,0CAGvB,CAOA,cAAIjD,GACA,OAAOH,KAAKF,SAASM,cAAcC,WAASd,QAACiB,OAAO6C,OAAOrD,KAAKH,YACpE,CAOA2B,sBAAAA,GAGI,OAFuBxB,KAAKF,SAASM,cAAcC,WAAAA,QAAUiD,UAAUC,QAAQC,YAEzDpD,cAAcC,WAAAA,QAAUC,KAAKmD,OAAOJ,OAAOrD,KAAKH,YAC1E,CAOAyB,kBAAAA,GACI,OAAOtB,KAAKG,WAAWC,cAAcC,WAASd,QAACiB,OAAO+C,QAAQG,OAClE,CAOA,QAAIC,GACA,OAAO3D,KAAKH,UAChB,CAOA,YAAI+D,GACA,OAAOC,SAAS7D,KAAKG,WAAWC,cAAcC,WAASd,QAACiB,OAAOiD,OAAOK,MAAMnB,MAAO,GACvF,CAOA,aAAIoB,GACA,MACMC,kBADkBhE,KAAKsB,qBACalB,cAAc,UAExD,OAAO6D,OAAOP,QA3LMQ,OA2LqBF,kBA1LtCE,OAAOC,iBAAiB,cA0LkCC,KAAIC,QAAUA,OAAO1B,QA3L9DuB,UA4LxB,CAOA,UAAIR,GACA,OAAO1D,KAAK+D,UAAUK,KAAIC,QAAUR,SAASQ,OAAQ,KACzD,CAOA,iBAAIC,GACA,MAAO,EACX,CAOA,eAAI9B,GACA,MAAO,CACHmB,KAAM3D,KAAK2D,KACXC,SAAU5D,KAAK4D,SACfF,OAAQ1D,KAAK0D,OACba,cAAevE,KAAKsE,cAE5B,GACH3E,SAAAJ,OAAA"}