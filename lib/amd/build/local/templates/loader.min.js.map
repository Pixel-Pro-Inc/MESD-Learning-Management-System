{"version":3,"file":"loader.min.js","sources":["../../../src/local/templates/loader.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\nimport $ from 'jquery';\nimport ajax from 'core/ajax';\nimport * as str from 'core/str';\nimport * as config from 'core/config';\nimport mustache from 'core/mustache';\nimport storage from 'core/localstorage';\nimport {getNormalisedComponent} from 'core/utils';\n\n/**\n * Template this.\n *\n * @module     core/local/templates/loader\n * @copyright  2023 Andrew Lyons <andrew@nicols.co.uk>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n * @since      4.3\n */\nexport default class Loader {\n    /** @var {String} themeName for the current render */\n    currentThemeName = '';\n\n    /** @var {Object[]} loadTemplateBuffer - List of templates to be loaded */\n    static loadTemplateBuffer = [];\n\n    /** @var {Bool} isLoadingTemplates - Whether templates are currently being loaded */\n    static isLoadingTemplates = false;\n\n    /** @var {Map} templateCache - Cache of already loaded template strings */\n    static templateCache = new Map();\n\n    /** @var {Promise[]} templatePromises - Cache of already loaded template promises */\n    static templatePromises = {};\n\n    /** @var {Promise[]} cachePartialPromises - Cache of already loaded template partial promises */\n    static cachePartialPromises = [];\n\n    /**\n     * A helper to get the search key\n     *\n     * @param {string} theme\n     * @param {string} templateName\n     * @returns {string}\n     */\n    static getSearchKey(theme, templateName) {\n        return `${theme}/${templateName}`;\n    }\n\n    /**\n     * Load a template.\n     *\n     * @method getTemplate\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {string} [themeName=config.theme] - The theme to load the template from\n     * @return {Promise} JQuery promise object resolved when the template has been fetched.\n     */\n    static getTemplate(templateName, themeName = config.theme) {\n        const searchKey = this.getSearchKey(themeName, templateName);\n\n        // If we haven't already seen this template then buffer it.\n        const cachedPromise = this.getTemplatePromiseFromCache(searchKey);\n        if (cachedPromise) {\n            return cachedPromise;\n        }\n\n        // Check the buffer to see if this template has already been added.\n        const existingBufferRecords = this.loadTemplateBuffer.filter((record) => record.searchKey === searchKey);\n        if (existingBufferRecords.length) {\n            // This template is already in the buffer so just return the existing\n            // promise. No need to add it to the buffer again.\n            return existingBufferRecords[0].deferred.promise();\n        }\n\n        // This is the first time this has been requested so let's add it to the buffer\n        // to be loaded.\n        const parts = templateName.split('/');\n        const component = getNormalisedComponent(parts.shift());\n        const name = parts.join('/');\n        const deferred = $.Deferred();\n\n        // Add this template to the buffer to be loaded.\n        this.loadTemplateBuffer.push({\n            component,\n            name,\n            theme: themeName,\n            searchKey,\n            deferred,\n        });\n\n        // We know there is at least one thing in the buffer so kick off a processing run.\n        this.processLoadTemplateBuffer();\n        return deferred.promise();\n    }\n\n    /**\n     * Store a template in the cache.\n     *\n     * @param {string} searchKey\n     * @param {string} templateSource\n     */\n    static setTemplateInCache(searchKey, templateSource) {\n        // Cache all of the dependent templates because we'll need them to render\n        // the requested template.\n        this.templateCache.set(searchKey, templateSource);\n    }\n\n    /**\n     * Fetch a template from the cache.\n     *\n     * @param {string} searchKey\n     * @returns {string}\n     */\n    static getTemplateFromCache(searchKey) {\n        return this.templateCache.get(searchKey);\n    }\n\n    /**\n     * Check whether a template is in the cache.\n     *\n     * @param {string} searchKey\n     * @returns {bool}\n     */\n    static hasTemplateInCache(searchKey) {\n        return this.templateCache.has(searchKey);\n    }\n\n    /**\n     * Prefetch a set of templates without rendering them.\n     *\n     * @param {Array} templateNames The list of templates to fetch\n     * @param {string} themeName\n     */\n    static prefetchTemplates(templateNames, themeName) {\n        templateNames.forEach((templateName) => this.prefetchTemplate(templateName, themeName));\n    }\n\n    /**\n     * Prefetech a sginle template without rendering it.\n     *\n     * @param {string} templateName\n     * @param {string} themeName\n     */\n    static prefetchTemplate(templateName, themeName) {\n        const searchKey = this.getSearchKey(themeName, templateName);\n\n        // If we haven't already seen this template then buffer it.\n        if (this.hasTemplateInCache(searchKey)) {\n            return;\n        }\n\n        // Check the buffer to see if this template has already been added.\n        const existingBufferRecords = this.loadTemplateBuffer.filter((record) => record.searchKey === searchKey);\n\n        if (existingBufferRecords.length) {\n            // This template is already in the buffer so just return the existing promise.\n            // No need to add it to the buffer again.\n            return;\n        }\n\n        // This is the first time this has been requested so let's add it to the buffer to be loaded.\n        const parts = templateName.split('/');\n        const component = getNormalisedComponent(parts.shift());\n        const name = parts.join('/');\n\n        // Add this template to the buffer to be loaded.\n        this.loadTemplateBuffer.push({\n            component,\n            name,\n            theme: themeName,\n            searchKey,\n            deferred: $.Deferred(),\n        });\n\n        this.processLoadTemplateBuffer();\n    }\n\n    /**\n     * Load a partial from the cache or ajax.\n     *\n     * @method partialHelper\n     * @param {string} name The partial name to load.\n     * @param {string} [themeName = config.theme] The theme to load the partial from.\n     * @return {string}\n     */\n    static partialHelper(name, themeName = config.theme) {\n        const searchKey = this.getSearchKey(themeName, name);\n\n        if (!this.hasTemplateInCache(searchKey)) {\n            new Error(`Failed to pre-fetch the template: ${name}`);\n        }\n        return this.getTemplateFromCache(searchKey);\n    }\n\n    /**\n     * Scan a template source for partial tags and return a list of the found partials.\n     *\n     * @method scanForPartials\n     * @param {string} templateSource - source template to scan.\n     * @return {Array} List of partials.\n     */\n    static scanForPartials(templateSource) {\n        const tokens = mustache.parse(templateSource);\n        const partials = [];\n\n        const findPartial = (tokens, partials) => {\n            let i;\n            for (i = 0; i < tokens.length; i++) {\n                const token = tokens[i];\n                if (token[0] == '>' || token[0] == '<') {\n                    partials.push(token[1]);\n                }\n                if (token.length > 4) {\n                    findPartial(token[4], partials);\n                }\n            }\n        };\n\n        findPartial(tokens, partials);\n\n        return partials;\n    }\n\n    /**\n     * Load a template and scan it for partials. Recursively fetch the partials.\n     *\n     * @method cachePartials\n     * @param {string} templateName - should consist of the component and the name of the template like this:\n     *                              core/menu (lib/templates/menu.mustache) or\n     *                              tool_bananas/yellow (admin/tool/bananas/templates/yellow.mustache)\n     * @param {string} [themeName=config.theme]\n     * @param {Array} parentage - A list of requested partials in this render chain.\n     * @return {Promise} JQuery promise object resolved when all partials are in the cache.\n     */\n    static cachePartials(templateName, themeName = config.theme, parentage = []) {\n        const searchKey = this.getSearchKey(themeName, templateName);\n\n        if (searchKey in this.cachePartialPromises) {\n            return this.cachePartialPromises[searchKey];\n        }\n\n        // This promise will not be resolved until all child partials are also resolved and ready.\n        // We create it here to allow us to check for recursive inclusion of templates.\n        // Keep track of the requested partials in this chain.\n        if (!parentage.length) {\n            parentage.push(searchKey);\n        }\n\n        this.cachePartialPromises[searchKey] = $.Deferred();\n        this._cachePartials(templateName, themeName, parentage).catch((error) => {\n            this.cachePartialPromises[searchKey].reject(error);\n        });\n\n        return this.cachePartialPromises[searchKey];\n    }\n\n    /**\n     * Cache the template partials for the specified template.\n     *\n     * @param {string} templateName\n     * @param {string} themeName\n     * @param {array} parentage\n     * @returns {promise<string>}\n     */\n    static async _cachePartials(templateName, themeName, parentage) {\n        const searchKey = this.getSearchKey(themeName, templateName);\n        const templateSource = await this.getTemplate(templateName, themeName);\n        const partials = this.scanForPartials(templateSource);\n        const uniquePartials = partials.filter((partialName) => {\n            // Check for recursion.\n            if (parentage.indexOf(`${themeName}/${partialName}`) >= 0) {\n                // Ignore templates which include a parent template already requested in the current chain.\n                return false;\n            }\n\n            // Ignore templates that include themselves.\n            return partialName !== templateName;\n        });\n\n        // Fetch any partial which has not already been fetched.\n        const fetchThemAll = uniquePartials.map((partialName) => {\n            parentage.push(`${themeName}/${partialName}`);\n            return this.cachePartials(partialName, themeName, parentage);\n        });\n\n        await Promise.all(fetchThemAll);\n        return this.cachePartialPromises[searchKey].resolve(templateSource);\n    }\n\n    /**\n     * Take all of the templates waiting in the buffer and load them from the server\n     * or from the cache.\n     *\n     * All of the templates that need to be loaded from the server will be batched up\n     * and sent in a single network request.\n     */\n    static processLoadTemplateBuffer() {\n        if (!this.loadTemplateBuffer.length) {\n            return;\n        }\n\n        if (this.isLoadingTemplates) {\n            return;\n        }\n\n        this.isLoadingTemplates = true;\n        // Grab any templates waiting in the buffer.\n        const templatesToLoad = this.loadTemplateBuffer.slice();\n        // This will be resolved with the list of promises for the server request.\n        const serverRequestsDeferred = $.Deferred();\n        const requests = [];\n        // Get a list of promises for each of the templates we need to load.\n        const templatePromises = templatesToLoad.map((templateData) => {\n            const component = getNormalisedComponent(templateData.component);\n            const name = templateData.name;\n            const searchKey = templateData.searchKey;\n            const theme = templateData.theme;\n            const templateDeferred = templateData.deferred;\n            let promise = null;\n\n            // Double check to see if this template happened to have landed in the\n            // cache as a dependency of an earlier template.\n            if (this.hasTemplateInCache(searchKey)) {\n                // We've seen this template so immediately resolve the existing promise.\n                promise = this.getTemplatePromiseFromCache(searchKey);\n            } else {\n                // We haven't seen this template yet so we need to request it from\n                // the server.\n                requests.push({\n                    methodname: 'core_output_load_template_with_dependencies',\n                    args: {\n                        component,\n                        template: name,\n                        themename: theme,\n                        lang: $('html').attr('lang').replace(/-/g, '_')\n                    }\n                });\n                // Remember the index in the requests list for this template so that\n                // we can get the appropriate promise back.\n                const index = requests.length - 1;\n\n                // The server deferred will be resolved with a list of all of the promises\n                // that were sent in the order that they were added to the requests array.\n                promise = serverRequestsDeferred.promise()\n                    .then((promises) => {\n                        // The promise for this template will be the one that matches the index\n                        // for it's entry in the requests array.\n                        //\n                        // Make sure the promise is added to the promises cache for this template\n                        // search key so that we don't request it again.\n                        templatePromises[searchKey] = promises[index].then((response) => {\n                            // Process all of the template dependencies for this template and add\n                            // them to the caches so that we don't request them again later.\n                            response.templates.forEach((data) => {\n                                data.component = getNormalisedComponent(data.component);\n                                const tempSearchKey = this.getSearchKey(\n                                    theme,\n                                    [data.component, data.name].join('/'),\n                                );\n\n                                // Cache all of the dependent templates because we'll need them to render\n                                // the requested template.\n                                this.setTemplateInCache(tempSearchKey, data.value);\n\n                                if (config.templaterev > 0) {\n                                    // The template cache is enabled - set the value there.\n                                    storage.set(`core_template/${config.templaterev}:${tempSearchKey}`, data.value);\n                                }\n                            });\n\n                            if (response.strings.length) {\n                                // If we have strings that the template needs then warm the string cache\n                                // with them now so that we don't need to re-fetch them.\n                                str.cache_strings(response.strings.map(({component, name, value}) => ({\n                                    component: getNormalisedComponent(component),\n                                    key: name,\n                                    value,\n                                })));\n                            }\n\n                            // Return the original template source that the user requested.\n                            if (this.hasTemplateInCache(searchKey)) {\n                                return this.getTemplateFromCache(searchKey);\n                            }\n\n                            return null;\n                        });\n\n                        return templatePromises[searchKey];\n                    });\n            }\n\n            return promise\n                // When we've successfully loaded the template then resolve the deferred\n                // in the buffer so that all of the calling code can proceed.\n                .then((source) => templateDeferred.resolve(source))\n                .catch((error) => {\n                    // If there was an error loading the template then reject the deferred\n                    // in the buffer so that all of the calling code can proceed.\n                    templateDeferred.reject(error);\n                    // Rethrow for anyone else listening.\n                    throw error;\n                });\n        });\n\n        if (requests.length) {\n            // We have requests to send so resolve the deferred with the promises.\n            serverRequestsDeferred.resolve(ajax.call(requests, true, false, false, 0, config.templaterev));\n        } else {\n            // Nothing to load so we can resolve our deferred.\n            serverRequestsDeferred.resolve();\n        }\n\n        // Once we've finished loading all of the templates then recurse to process\n        // any templates that may have been added to the buffer in the time that we\n        // were fetching.\n        $.when.apply(null, templatePromises)\n            .then(() => {\n                // Remove the templates we've loaded from the buffer.\n                this.loadTemplateBuffer.splice(0, templatesToLoad.length);\n                this.isLoadingTemplates = false;\n                this.processLoadTemplateBuffer();\n                return;\n            })\n            .catch(() => {\n                // Remove the templates we've loaded from the buffer.\n                this.loadTemplateBuffer.splice(0, templatesToLoad.length);\n                this.isLoadingTemplates = false;\n                this.processLoadTemplateBuffer();\n            });\n    }\n\n    /**\n     * Search the various caches for a template promise for the given search key.\n     * The search key should be in the format <theme>/<component>/<template> e.g. boost/core/modal.\n     *\n     * If the template is found in any of the caches it will populate the other caches with\n     * the same data as well.\n     *\n     * @param {String} searchKey The template search key in the format <theme>/<component>/<template> e.g. boost/core/modal\n     * @returns {Object|null} jQuery promise resolved with the template source\n     */\n    static getTemplatePromiseFromCache(searchKey) {\n        // First try the cache of promises.\n        if (searchKey in this.templatePromises) {\n            return this.templatePromises[searchKey];\n        }\n\n        // Check the module cache.\n        if (this.hasTemplateInCache(searchKey)) {\n            const templateSource = this.getTemplateFromCache(searchKey);\n            // Add this to the promises cache for future.\n            this.templatePromises[searchKey] = $.Deferred().resolve(templateSource).promise();\n            return this.templatePromises[searchKey];\n        }\n\n        if (config.templaterev <= 0) {\n            // Template caching is disabled. Do not store in persistent storage.\n            return null;\n        }\n\n        // Now try local storage.\n        const cached = storage.get(`core_template/${config.templaterev}:${searchKey}`);\n        if (cached) {\n            // Add this to the module cache for future.\n            this.setTemplateInCache(searchKey, cached);\n\n            // Add to the promises cache for future.\n            this.templatePromises[searchKey] = $.Deferred().resolve(cached).promise();\n            return this.templatePromises[searchKey];\n        }\n\n        return null;\n    }\n}\n"],"names":["_getRequireWildcardCache","e","WeakMap","r","t","_interopRequireWildcard","__esModule","default","has","get","n","__proto__","a","Object","defineProperty","getOwnPropertyDescriptor","u","prototype","hasOwnProperty","call","i","set","_interopRequireDefault","obj","_jquery","_ajax","str","config","_mustache","_localstorage","Loader","currentThemeName","static","Map","getSearchKey","theme","templateName","getTemplate","themeName","arguments","length","undefined","searchKey","this","cachedPromise","getTemplatePromiseFromCache","existingBufferRecords","loadTemplateBuffer","filter","record","deferred","promise","parts","split","component","getNormalisedComponent","shift","name","join","$","Deferred","push","processLoadTemplateBuffer","setTemplateInCache","templateSource","templateCache","getTemplateFromCache","hasTemplateInCache","prefetchTemplates","templateNames","forEach","prefetchTemplate","partialHelper","Error","scanForPartials","tokens","mustache","parse","partials","findPartial","token","cachePartials","parentage","cachePartialPromises","_cachePartials","catch","error","reject","fetchThemAll","partialName","indexOf","map","Promise","all","resolve","isLoadingTemplates","templatesToLoad","slice","serverRequestsDeferred","requests","templatePromises","templateData","templateDeferred","methodname","args","template","themename","lang","attr","replace","index","then","promises","response","templates","data","tempSearchKey","value","templaterev","storage","strings","cache_strings","_ref","key","source","ajax","when","apply","splice","cached","_exports"],"mappings":"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"}